#!/bin/bash

# MCP Registry CLI - A pleasant-to-use command-line tool for the MCP Registry
# Version: 0.0.1
# Author: MCP Registry CLI Team

set -euo pipefail

# Script directory and configuration
SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
SCRIPT_NAME="$(basename "$0")"
readonly SCRIPT_DIR
readonly SCRIPT_NAME

export SCRIPT_DIR  # Export for external use
readonly VERSION="0.2.4"

# Configuration
readonly MCP_REGISTRY_BASE_URL="${MCP_REGISTRY_BASE_URL:-https://registry.modelcontextprotocol.io}"
readonly CACHE_DIR="${MCP_CACHE_DIR:-$HOME/.cache/mcpreg}"
readonly CONFIG_DIR="${MCP_CONFIG_DIR:-$HOME/.config/mcpreg}"
readonly INSTALLED_PACKAGES_FILE="$CONFIG_DIR/installed_packages.json"
readonly MCP_CONFIG_FILE="$CONFIG_DIR/mcp_config.json"

# Colors for output
readonly RED='\033[0;31m'
readonly GREEN='\033[0;32m'
readonly YELLOW='\033[1;33m'
readonly BLUE='\033[0;34m'
readonly NC='\033[0m' # No Color

# Logging functions
log_info() {
    echo -e "${BLUE}[INFO]${NC} $*" >&2
}

log_success() {
    echo -e "${GREEN}[SUCCESS]${NC} $*" >&2
}

log_warning() {
    echo -e "${YELLOW}[WARNING]${NC} $*" >&2
}

log_error() {
    echo -e "${RED}[ERROR]${NC} $*" >&2
}

# Error handling
error_exit() {
    log_error "$1"
    exit "${2:-1}"
}

# Help function
show_help() {
    cat << EOF
MCP Registry CLI - A pleasant-to-use command-line tool for the MCP Registry

USAGE:
    $SCRIPT_NAME <command> [options]

COMMANDS:
    search <query>     Search for MCP servers
    list               List available MCP servers
    installed          List installed MCP servers
    install <name>     Install an MCP server (supports fuzzy matching)
    info <name>        Get information about an MCP server (supports fuzzy matching)
    uninstall <name>   Uninstall an MCP server (supports fuzzy matching)
    update [name]      Update installed MCP servers (all or specific, supports fuzzy matching)
    config [action]    Manage configuration (show|clear-cache|cache-info)
    auth               Authenticate with GitHub CLI (gh auth login)
    commands           List available commands
    --help, -h         Show this help message
    --version, -v      Show version information

EXAMPLES:
    $SCRIPT_NAME search filesystem
    $SCRIPT_NAME list
    $SCRIPT_NAME install filesystem
    $SCRIPT_NAME info filesystem
    $SCRIPT_NAME config
    $SCRIPT_NAME config clear-cache

ENVIRONMENT VARIABLES:
    GITHUB_TOKEN           GitHub authentication token (seamless auth)
    GITHUB_AUTH_TOKEN      Alternative GitHub authentication token
    MCP_REGISTRY_BASE_URL  MCP Registry base URL (default: https://registry.modelcontextprotocol.io)
    MCP_CACHE_DIR          Cache directory (default: ~/.cache/mcpreg)
    MCP_CONFIG_DIR         Config directory (default: ~/.config/mcpreg)

For more information, visit: https://github.com/your-org/mcp-registry-cli
EOF
}

# Version function
show_version() {
    echo "$SCRIPT_NAME version $VERSION"
}

# Check dependencies
check_dependencies() {
    local missing_deps=()
    
    # Check for required commands
    command -v curl >/dev/null 2>&1 || missing_deps+=("curl")
    command -v jq >/dev/null 2>&1 || missing_deps+=("jq")
    
    if [[ ${#missing_deps[@]} -gt 0 ]]; then
        log_error "Missing required dependencies: ${missing_deps[*]}"
        log_info "Please install the missing dependencies and try again."
        log_info "On macOS: brew install curl jq"
        log_info "On Ubuntu/Debian: sudo apt-get install curl jq"
        log_info "On CentOS/RHEL: sudo yum install curl jq"
        exit 1
    fi
}

# Initialize directories
init_directories() {
    mkdir -p "$CACHE_DIR" "$CONFIG_DIR"
    
    # Initialize package tracking files if they don't exist
    if [[ ! -f "$INSTALLED_PACKAGES_FILE" ]]; then
        echo '{"packages": {}}' > "$INSTALLED_PACKAGES_FILE"
    fi
    
    if [[ ! -f "$MCP_CONFIG_FILE" ]]; then
        echo '{"mcpServers": {}}' > "$MCP_CONFIG_FILE"
    fi
}

# Caching functions
get_cache_file() {
    local endpoint="$1"
    # Create a safe filename from the endpoint
    local safe_name
    safe_name="${endpoint//[^a-zA-Z0-9._-]/_}"
    echo "$CACHE_DIR/${safe_name}.json"
}

is_cache_valid() {
    local cache_file="$1"
    local max_age="${2:-300}" # Default 5 minutes
    
    if [[ ! -f "$cache_file" ]]; then
        return 1
    fi
    
    local file_age
    file_age=$(($(date +%s) - $(stat -f %m "$cache_file" 2>/dev/null || stat -c %Y "$cache_file" 2>/dev/null)))
    
    if [[ $file_age -lt $max_age ]]; then
        return 0
    else
        return 1
    fi
}

get_from_cache() {
    local cache_file="$1"
    
    if [[ -f "$cache_file" ]]; then
        cat "$cache_file"
        return 0
    else
        return 1
    fi
}

save_to_cache() {
    local cache_file="$1"
    local data="$2"
    
    echo "$data" > "$cache_file"
}

# Enhanced API call with caching
api_call_with_cache() {
    local endpoint="$1"
    local method="${2:-GET}"
    local data="${3:-}"
    local cache_ttl="${4:-300}" # Default 5 minutes cache
    local timeout="${5:-10}"    # Default 10 second timeout
    
    local cache_file
    cache_file=$(get_cache_file "$endpoint")
    
    # For GET requests, try cache first
    if [[ "$method" == "GET" ]] && is_cache_valid "$cache_file" "$cache_ttl"; then
        log_info "Using cached data for $endpoint"
        get_from_cache "$cache_file"
        return 0
    fi
    
    # Make API call with timeout
    local response
    response=$(api_call "$endpoint" "$method" "$data" "$timeout")
    local api_result=$?
    
    # Cache successful GET responses
    if [[ $api_result -eq 0 ]] && [[ "$method" == "GET" ]]; then
        save_to_cache "$cache_file" "$response"
    fi
    
    echo "$response"
    return $api_result
}

# Package management functions
get_installed_packages() {
    if [[ -f "$INSTALLED_PACKAGES_FILE" ]]; then
        cat "$INSTALLED_PACKAGES_FILE"
    else
        echo '{"packages": {}}'
    fi
}

is_package_installed() {
    local package_name="$1"
    local installed_packages
    installed_packages=$(get_installed_packages)
    
    echo "$installed_packages" | jq -e ".packages.\"$package_name\"" >/dev/null 2>&1
}

get_package_info() {
    local package_name="$1"
    local installed_packages
    installed_packages=$(get_installed_packages)
    
    echo "$installed_packages" | jq -r ".packages.\"$package_name\" // null"
}

add_installed_package() {
    local package_name="$1"
    local package_info="$2"
    local installed_packages
    installed_packages=$(get_installed_packages)
    
    local updated_packages
    updated_packages=$(echo "$installed_packages" | jq ".packages.\"$package_name\" = $package_info")
    echo "$updated_packages" > "$INSTALLED_PACKAGES_FILE"
}

remove_installed_package() {
    local package_name="$1"
    local installed_packages
    installed_packages=$(get_installed_packages)
    
    local updated_packages
    updated_packages=$(echo "$installed_packages" | jq "del(.packages.\"$package_name\")")
    echo "$updated_packages" > "$INSTALLED_PACKAGES_FILE"
}

get_mcp_config() {
    if [[ -f "$MCP_CONFIG_FILE" ]]; then
        cat "$MCP_CONFIG_FILE"
    else
        echo '{"mcpServers": {}}'
    fi
}

add_mcp_server_config() {
    local server_name="$1"
    local command="$2"
    local args="$3"
    local config
    config=$(get_mcp_config)
    
    local server_config
    server_config=$(jq -n --arg cmd "$command" --argjson args "$args" '{command: $cmd, args: $args}')
    
    local updated_config
    updated_config=$(echo "$config" | jq ".mcpServers.\"$server_name\" = $server_config")
    echo "$updated_config" > "$MCP_CONFIG_FILE"
}

remove_mcp_server_config() {
    local server_name="$1"
    local config
    config=$(get_mcp_config)
    
    local updated_config
    updated_config=$(echo "$config" | jq "del(.mcpServers.\"$server_name\")")
    echo "$updated_config" > "$MCP_CONFIG_FILE"
}

detect_package_manager() {
    local package_name="$1"
    
    # Check if it's an npm package
    if command -v npm >/dev/null 2>&1; then
        if npm view "$package_name" >/dev/null 2>&1; then
            echo "npm"
            return 0
        fi
    fi
    
    # Check if it's a pip package
    if command -v pip >/dev/null 2>&1; then
        if pip show "$package_name" >/dev/null 2>&1; then
            echo "pip"
            return 0
        fi
    fi
    
    # Check if it's a pip3 package
    if command -v pip3 >/dev/null 2>&1; then
        if pip3 show "$package_name" >/dev/null 2>&1; then
            echo "pip3"
            return 0
        fi
    fi
    
    echo "unknown"
    return 1
}

# Server selection function for fuzzy matching
select_server_from_matches() {
    local query="$1"
    local action="$2"  # "install", "uninstall", "update", "info"
    
    log_info "Searching for servers matching: $query"
    
    local search_response
    if ! search_response=$(api_call_with_cache "/v0/servers?search=$query" "GET" "" 300 5 2>/dev/null); then
        log_warning "API is currently unavailable or timed out. Cannot search for servers."
        return 1
    fi
    
    local matches
    matches=$(echo "$search_response" | jq -r '.servers[]? | .name' 2>/dev/null)
    
    if [[ -z "$matches" ]]; then
        echo "No servers found matching '$query'"
        echo
        echo "Try searching for available servers:"
        echo "  $SCRIPT_NAME search $query"
        echo "  $SCRIPT_NAME list"
        return 1
    fi
    
    # Count matches
    local match_count
    match_count=$(echo "$matches" | wc -l)
    
    if [[ $match_count -eq 1 ]]; then
        # Single match found, return it
        local exact_name
        exact_name=$(echo "$matches" | head -n1)
        log_info "Found single match: $exact_name"
        echo "$exact_name"
        return 0
    else
        # Multiple matches found, prompt user to select
        echo "Found $match_count servers matching '$query':"
        echo
        
        local i=1
        local server_names=()
        echo "$matches" | while read -r server_name; do
            echo "  $i) $server_name"
            server_names+=("$server_name")
            ((i++))
        done
        echo
        
        # Check if we're in a non-interactive environment (like tests)
        if [[ ! -t 0 ]] || [[ -n "${BATS_TEST_FILENAME:-}" ]]; then
            # Non-interactive mode - return first match
            local first_match
            first_match=$(echo "$matches" | head -n1)
            log_info "Non-interactive mode: auto-selecting first match: $first_match"
            echo "$first_match"
            return 0
        fi
        
        # Read user selection
        local selection
        while true; do
            echo -n "Select a server to $action (1-$match_count) or 'q' to quit: "
            read -r selection
            
            if [[ "$selection" == "q" || "$selection" == "quit" ]]; then
                echo "Cancelled."
                return 1
            fi
            
            if [[ "$selection" =~ ^[0-9]+$ ]] && [[ $selection -ge 1 ]] && [[ $selection -le $match_count ]]; then
                break
            else
                echo "Please enter a number between 1 and $match_count, or 'q' to quit."
            fi
        done
        
        # Get the selected server name
        local selected_name
        selected_name=$(echo "$matches" | sed -n "${selection}p")
        
        log_info "Selected: $selected_name"
        echo "$selected_name"
        return 0
    fi
}

# Authentication functions
validate_github_token() {
    local token="$1"
    
    if [[ -z "$token" ]]; then
        return 1
    fi
    
    # Test token by making a simple API call to GitHub
    local response
    if ! response=$(curl -s -w "\n%{http_code}" \
        -H "Authorization: Bearer $token" \
        -H "Accept: application/vnd.github.v3+json" \
        "https://api.github.com/user" 2>/dev/null); then
        return 1
    fi
    
    local http_code
    http_code=$(echo "$response" | tail -n1)
    local body
    body=$(echo "$response" | sed '$d')
    
    if [[ "$http_code" -eq 200 ]]; then
        local username
        username=$(echo "$body" | jq -r '.login // "unknown"' 2>/dev/null)
        log_info "GitHub token validated for user: $username"
        return 0
    else
        log_warning "GitHub token validation failed (status: $http_code)"
        return 1
    fi
}

check_auth() {
    local token=""
    
    # Check for GitHub tokens in environment variables first
    if [[ -n "${GITHUB_TOKEN:-}" ]]; then
        token="$GITHUB_TOKEN"
    elif [[ -n "${GITHUB_AUTH_TOKEN:-}" ]]; then
        token="$GITHUB_AUTH_TOKEN"
    fi
    
    # If no env token, try to get token from GitHub CLI
    if [[ -z "$token" ]] && command -v gh >/dev/null 2>&1; then
        if gh auth status >/dev/null 2>&1; then
            token=$(gh auth token 2>/dev/null)
            if [[ -n "$token" ]]; then
                log_info "Using GitHub CLI authentication"
            fi
        fi
    fi
    
    if [[ -n "$token" ]]; then
        if validate_github_token "$token"; then
            log_info "Using validated GitHub token for authentication"
            return 0
        else
            log_warning "GitHub token is invalid or expired"
            return 1
        fi
    else
        log_info "No GitHub authentication found"
        log_info "Run 'mcpreg auth' to authenticate with GitHub CLI"
        return 0  # Don't exit on missing token, just log info
    fi
}

# GitHub CLI authentication
browser_auth() {
    log_info "Setting up GitHub authentication using GitHub CLI..."
    
    # Check if gh CLI is installed
    if ! command -v gh >/dev/null 2>&1; then
        log_error "GitHub CLI (gh) is not installed"
        log_info "Please install it first:"
        log_info "  macOS: brew install gh"
        log_info "  Linux: https://cli.github.com/"
        log_info "  Windows: winget install GitHub.cli"
        return 1
    fi
    
    # Check if already authenticated
    if gh auth status >/dev/null 2>&1; then
        log_info "GitHub CLI is already authenticated"
        log_success "Using existing GitHub CLI authentication"
        return 0
    fi
    
    # Authenticate with GitHub CLI
    log_info "Starting GitHub CLI authentication..."
    log_info "This will open your browser for GitHub OAuth"
    
    if gh auth login --web >/dev/null 2>&1; then
        log_success "GitHub authentication completed successfully"
        return 0
    else
        log_error "GitHub authentication failed"
        log_info "You can also set GITHUB_TOKEN manually:"
        log_info "  export GITHUB_TOKEN=your_token_here"
        return 1
    fi
}

# API functions
api_call() {
    local endpoint="$1"
    local method="${2:-GET}"
    local data="${3:-}"
    local timeout="${4:-10}"  # Default 10 second timeout
    
    local url="${MCP_REGISTRY_BASE_URL}${endpoint}"
    local curl_args=(-s -w "\n%{http_code}" --max-time "$timeout" --connect-timeout 5)
    
    if [[ "$method" == "POST" ]] && [[ -n "$data" ]]; then
        curl_args+=(-X POST -H "Content-Type: application/json" -d "$data")
    fi
    
    # Add authentication if available
    if [[ -n "${GITHUB_TOKEN:-}" ]]; then
        curl_args+=(-H "Authorization: Bearer $GITHUB_TOKEN")
    elif [[ -n "${GITHUB_AUTH_TOKEN:-}" ]]; then
        curl_args+=(-H "Authorization: Bearer $GITHUB_AUTH_TOKEN")
    fi
    
    local response
    if ! response=$(curl "${curl_args[@]}" "$url" 2>/dev/null); then
        log_error "Failed to connect to MCP Registry (timeout: ${timeout}s)"
        return 1
    fi
    
    local http_code
    http_code=$(echo "$response" | tail -n1)
    local body
    body=$(echo "$response" | sed '$d')
    
    if [[ "$http_code" -ge 400 ]]; then
        log_warning "API request failed with status $http_code"
        echo "$body" | jq -r '.message // .error // "Unknown error"' 2>/dev/null || echo "$body"
        return 1
    fi
    
    echo "$body"
}

# Command functions
cmd_search() {
    local query="${1:-}"
    if [[ -z "$query" ]]; then
        error_exit "Search query is required. Usage: $SCRIPT_NAME search <query>"
    fi
    
    log_info "Searching for: $query"
    
    local response
    response=$(api_call_with_cache "/v0/servers?search=$query" "GET" "" 300 5) || {
        log_warning "API is currently unavailable or timed out. Showing example results."
        echo "MCP Registry API is currently experiencing issues."
        echo "Example servers matching '$query':"
        echo "  • io.modelcontextprotocol/filesystem - Filesystem operations server"
        echo "  • io.modelcontextprotocol/git - Git repository operations"
        return 0
    }
    
    local count
    count=$(echo "$response" | jq -r '.metadata.count // 0')
    
    if [[ "$count" -eq 0 ]]; then
        echo "No servers found matching '$query'"
        return 0
    fi
    
    echo "Found $count server(s) matching '$query':"
    echo
    
    echo "$response" | jq -r '.servers[] | "\(.name) - \(.description // "No description")"' | while read -r line; do
        echo "  • $line"
    done
}

cmd_list() {
    local limit="${1:-20}"
    
    log_info "Listing available MCP servers (limit: $limit)"
    
    local response
    response=$(api_call_with_cache "/v0/servers?limit=$limit" "GET" "" 300 5) || {
        log_warning "API is currently unavailable or timed out. Showing cached data or placeholder."
        # For now, show a placeholder message
        echo "MCP Registry API is currently experiencing issues."
        echo "Please try again later or check https://registry.modelcontextprotocol.io for status."
        echo
        echo "Example servers that would be available:"
        echo "  • io.modelcontextprotocol/filesystem - Filesystem operations server"
        echo "  • io.modelcontextprotocol/git - Git repository operations"
        echo "  • io.modelcontextprotocol/sqlite - SQLite database operations"
        return 0
    }
    
    local count
    count=$(echo "$response" | jq -r '.metadata.count // 0')
    
    echo "Available MCP servers ($count total):"
    echo
    
    echo "$response" | jq -r '.servers[] | "\(.name) - \(.description // "No description")"' | while read -r line; do
        echo "  • $line"
    done
}

cmd_install() {
    local name="${1:-}"
    if [[ -z "$name" ]]; then
        error_exit "Server name is required. Usage: $SCRIPT_NAME install <name>"
    fi
    
    log_info "Installing MCP server: $name"
    
    # Check if already installed
    if is_package_installed "$name"; then
        log_warning "Package '$name' is already installed"
        local package_info
        package_info=$(get_package_info "$name")
        local version
        version=$(echo "$package_info" | jq -r '.version // "unknown"')
        echo "Installed version: $version"
        return 0
    fi
    
    # First try exact match
    local server_info
    if server_info=$(api_call_with_cache "/v0/servers/$name" 2>/dev/null); then
        # Exact match found, proceed with installation
        install_from_server_info "$server_info" "$name"
        return $?
    fi
    
    # If exact match fails, try fuzzy search
    log_info "Exact match not found, searching for similar servers..."
    local selected_server
    if selected_server=$(select_server_from_matches "$name" "install"); then
        # Get server information for the selected server
        if server_info=$(api_call_with_cache "/v0/servers/$selected_server" 2>/dev/null); then
            install_from_server_info "$server_info" "$selected_server"
            return $?
        else
            error_exit "Failed to get information for selected server: $selected_server"
        fi
    else
        # No matches found or user cancelled, try direct installation
        log_warning "No matching servers found, attempting direct installation..."
        install_package_direct "$name"
        return $?
    fi
}

# shellcheck disable=SC2317
install_from_server_info() {
    local server_info="$1"
    local server_name="$2"
    
    # Extract package information
    local package_name
    package_name=$(echo "$server_info" | jq -r '.packages[0].identifier // .name // "'"$server_name"'"')
    local registry_type
    registry_type=$(echo "$server_info" | jq -r '.packages[0].registry_type // "npm"')
    local version
    version=$(echo "$server_info" | jq -r '.packages[0].version // "latest"')
    
    log_info "Found package: $package_name (type: $registry_type, version: $version)"
    
    # Install based on registry type
    case "$registry_type" in
        "npm")
            install_npm_package "$package_name" "$version" "$server_name"
            ;;
        "pip"|"pypi")
            install_pip_package "$package_name" "$version" "$server_name"
            ;;
        *)
            log_warning "Unknown registry type '$registry_type', attempting npm installation..."
            install_npm_package "$package_name" "$version" "$server_name"
            ;;
    esac
}

# shellcheck disable=SC2317
install_npm_package() {
    local package_name="$1"
    local version="$2"
    local server_name="$3"
    
    # Check if npm is available
    if ! command -v npm >/dev/null 2>&1; then
        error_exit "npm is not installed. Please install Node.js and npm first."
    fi
    
    log_info "Installing npm package: $package_name@$version"
    
    # Install the package
    if npm install -g "$package_name@$version" >/dev/null 2>&1; then
        log_success "Successfully installed $package_name@$version"
        
        # Add to installed packages tracking
        local package_info
        package_info=$(jq -n --arg name "$package_name" --arg version "$version" --arg type "npm" '{name: $name, version: $version, type: $type, installed_at: now}')
        add_installed_package "$server_name" "$package_info"
        
        # Add to MCP configuration
        local args
        args=$(jq -n --arg pkg "$package_name" '[$pkg]')
        add_mcp_server_config "$server_name" "npx" "$args"
        
        log_success "Added $server_name to MCP configuration"
        echo
        echo "To use this server, add the following to your MCP client configuration:"
        echo "  \"$server_name\": {"
        echo "    \"command\": \"npx\","
        echo "    \"args\": [\"$package_name\"]"
        echo "  }"
        
    else
        error_exit "Failed to install npm package: $package_name"
    fi
}

# shellcheck disable=SC2317
install_pip_package() {
    local package_name="$1"
    local version="$2"
    local server_name="$3"
    
    # Check if pip is available
    local pip_cmd=""
    if command -v pip3 >/dev/null 2>&1; then
        pip_cmd="pip3"
    elif command -v pip >/dev/null 2>&1; then
        pip_cmd="pip"
    else
        error_exit "pip is not installed. Please install Python and pip first."
    fi
    
    log_info "Installing pip package: $package_name==$version"
    
    # Install the package
    if $pip_cmd install "$package_name==$version" >/dev/null 2>&1; then
        log_success "Successfully installed $package_name==$version"
        
        # Add to installed packages tracking
        local package_info
        package_info=$(jq -n --arg name "$package_name" --arg version "$version" --arg type "pip" '{name: $name, version: $version, type: $type, installed_at: now}')
        add_installed_package "$server_name" "$package_info"
        
        # Add to MCP configuration
        local args
        args=$(jq -n --arg pkg "$package_name" '[$pkg]')
        add_mcp_server_config "$server_name" "$package_name" "$args"
        
        log_success "Added $server_name to MCP configuration"
        echo
        echo "To use this server, add the following to your MCP client configuration:"
        echo "  \"$server_name\": {"
        echo "    \"command\": \"$package_name\","
        echo "    \"args\": []"
        echo "  }"
        
    else
        error_exit "Failed to install pip package: $package_name"
    fi
}

# shellcheck disable=SC2317
install_package_direct() {
    local package_name="$1"
    
    log_info "Attempting direct installation of: $package_name"
    
    # Try npm first
    if command -v npm >/dev/null 2>&1; then
        if npm view "$package_name" >/dev/null 2>&1; then
            log_info "Found package in npm registry"
            install_npm_package "$package_name" "latest" "$package_name"
            return $?
        fi
    fi
    
    # Try pip
    local pip_cmd=""
    if command -v pip3 >/dev/null 2>&1; then
        pip_cmd="pip3"
    elif command -v pip >/dev/null 2>&1; then
        pip_cmd="pip"
    fi
    
    if [[ -n "$pip_cmd" ]]; then
        if $pip_cmd show "$package_name" >/dev/null 2>&1; then
            log_info "Found package in pip registry"
            install_pip_package "$package_name" "latest" "$package_name"
            return $?
        fi
    fi
    
    error_exit "Package '$package_name' not found in npm or pip registries"
}

cmd_info() {
    local name="${1:-}"
    if [[ -z "$name" ]]; then
        error_exit "Server name is required. Usage: $SCRIPT_NAME info <name>"
    fi
    
    log_info "Getting information for: $name"
    
    # First try exact match
    local response
    if response=$(api_call_with_cache "/v0/servers/$name" 2>/dev/null); then
        display_server_info "$response"
        return 0
    fi
    
    # If exact match fails, try fuzzy search
    log_info "Exact match not found, searching for similar servers..."
    
    local search_response
    if ! search_response=$(api_call_with_cache "/v0/servers?search=$name" 2>/dev/null); then
        log_warning "API is currently unavailable. Cannot search for servers."
        error_exit "Failed to get server information and search is unavailable"
    fi
    
    local matches
    matches=$(echo "$search_response" | jq -r '.servers[]? | .name' 2>/dev/null)
    
    if [[ -z "$matches" ]]; then
        echo "No servers found matching '$name'"
        echo
        echo "Try searching for available servers:"
        echo "  $SCRIPT_NAME search $name"
        echo "  $SCRIPT_NAME list"
        return 1
    fi
    
    # Count matches
    local match_count
    match_count=$(echo "$matches" | wc -l)
    
    if [[ $match_count -eq 1 ]]; then
        # Single match found, use it
        local exact_name
        exact_name=$(echo "$matches" | head -n1)
        log_info "Found single match: $exact_name"
        
        # Extract the server info from the search response
        local server_info
        server_info=$(echo "$search_response" | jq -r ".servers[] | select(.name == \"$exact_name\")")
        
        if [[ -n "$server_info" ]] && [[ "$server_info" != "null" ]]; then
            display_server_info "$server_info"
            return 0
        else
            error_exit "Failed to get information for matched server: $exact_name"
        fi
    else
        # Multiple matches found, prompt user to select
        echo "Found $match_count servers matching '$name':"
        echo
        
        local i=1
        local server_names=()
        echo "$matches" | while read -r server_name; do
            echo "  $i) $server_name"
            server_names+=("$server_name")
            ((i++))
        done
        echo
        
        # Check if we're in a non-interactive environment (like tests)
        if [[ ! -t 0 ]] || [[ -n "${BATS_TEST_FILENAME:-}" ]]; then
            # Non-interactive mode - auto-select first match and get its info
            local first_match
            first_match=$(echo "$matches" | head -n1)
            log_info "Non-interactive mode: auto-selecting first match: $first_match"
            
            # Extract the server info from the search response
            local server_info
            server_info=$(echo "$search_response" | jq -r ".servers[] | select(.name == \"$first_match\")")
            
            if [[ -n "$server_info" ]] && [[ "$server_info" != "null" ]]; then
                display_server_info "$server_info"
                return 0
            else
                error_exit "Failed to get information for selected server: $first_match"
            fi
        fi
        
        # Read user selection
        local selection
        while true; do
            echo -n "Select a server (1-$match_count) or 'q' to quit: "
            read -r selection
            
            if [[ "$selection" == "q" || "$selection" == "quit" ]]; then
                echo "Cancelled."
                return 1
            fi
            
            if [[ "$selection" =~ ^[0-9]+$ ]] && [[ $selection -ge 1 ]] && [[ $selection -le $match_count ]]; then
                break
            else
                echo "Please enter a number between 1 and $match_count, or 'q' to quit."
            fi
        done
        
        # Get the selected server name
        local selected_name
        selected_name=$(echo "$matches" | sed -n "${selection}p")
        
        log_info "Selected: $selected_name"
        
        # Extract the server info from the search response
        local server_info
        server_info=$(echo "$search_response" | jq -r ".servers[] | select(.name == \"$selected_name\")")
        
        if [[ -n "$server_info" ]] && [[ "$server_info" != "null" ]]; then
            display_server_info "$server_info"
            return 0
        else
            error_exit "Failed to get information for selected server: $selected_name"
        fi
    fi
}

# Helper function to display server information
display_server_info() {
    local response="$1"
    
    # Parse and display server information
    local server_name
    server_name=$(echo "$response" | jq -r '.name // "Unknown"')
    local description
    description=$(echo "$response" | jq -r '.description // "No description"')
    local version
    version=$(echo "$response" | jq -r '.version // "Unknown"')
    local status
    status=$(echo "$response" | jq -r '.status // "Unknown"')
    
    echo "Server Information:"
    echo "=================="
    echo "Name:        $server_name"
    echo "Description: $description"
    echo "Version:     $version"
    echo "Status:      $status"
    echo
    
    # Show packages if available
    local packages
    packages=$(echo "$response" | jq -r '.packages[]? | "\(.registry_type): \(.identifier)@\(.version)"' 2>/dev/null)
    
    if [[ -n "$packages" ]]; then
        echo "Packages:"
        echo "$packages" | while read -r package; do
            echo "  • $package"
        done
        echo
    fi
    
    # Show remotes if available
    local remotes
    remotes=$(echo "$response" | jq -r '.remotes[]? | "\(.type): \(.url)"' 2>/dev/null)
    
    if [[ -n "$remotes" ]]; then
        echo "Remotes:"
        echo "$remotes" | while read -r remote; do
            echo "  • $remote"
        done
        echo
    fi
}

cmd_uninstall() {
    local name="${1:-}"
    if [[ -z "$name" ]]; then
        error_exit "Server name is required. Usage: $SCRIPT_NAME uninstall <name>"
    fi
    
    log_info "Uninstalling MCP server: $name"
    
    # Check if package is installed (exact match)
    if is_package_installed "$name"; then
        uninstall_package "$name"
        return $?
    fi
    
    # If not found, try fuzzy matching with installed packages
    log_info "Package '$name' not found, searching installed packages..."
    local installed_packages
    installed_packages=$(get_installed_packages)
    local package_names
    package_names=$(echo "$installed_packages" | jq -r '.packages | keys[]')
    
    local matches
    matches=$(echo "$package_names" | grep -i "$name" || true)
    
    if [[ -z "$matches" ]]; then
        log_warning "No installed packages found matching '$name'"
        echo
        echo "Installed packages:"
        if [[ -n "$package_names" ]]; then
            echo "$package_names" | while read -r pkg; do
                echo "  • $pkg"
            done
        else
            echo "  (none)"
        fi
        return 0
    fi
    
    # Count matches
    local match_count
    match_count=$(echo "$matches" | wc -l)
    
    if [[ $match_count -eq 1 ]]; then
        # Single match found, use it
        local exact_name
        exact_name=$(echo "$matches" | head -n1)
        log_info "Found single match: $exact_name"
        uninstall_package "$exact_name"
        return $?
    else
        # Multiple matches found, prompt user to select
        echo "Found $match_count installed packages matching '$name':"
        echo
        
        local i=1
        echo "$matches" | while read -r package_name; do
            echo "  $i) $package_name"
            ((i++))
        done
        echo
        
        # Check if we're in a non-interactive environment (like tests)
        if [[ ! -t 0 ]] || [[ -n "${BATS_TEST_FILENAME:-}" ]]; then
            # Non-interactive mode - return first match
            local first_match
            first_match=$(echo "$matches" | head -n1)
            log_info "Non-interactive mode: auto-selecting first match: $first_match"
            echo "$first_match"
            return 0
        fi
        
        # Read user selection
        local selection
        while true; do
            echo -n "Select a package to uninstall (1-$match_count) or 'q' to quit: "
            read -r selection
            
            if [[ "$selection" == "q" || "$selection" == "quit" ]]; then
                echo "Cancelled."
                return 1
            fi
            
            if [[ "$selection" =~ ^[0-9]+$ ]] && [[ $selection -ge 1 ]] && [[ $selection -le $match_count ]]; then
                break
            else
                echo "Please enter a number between 1 and $match_count, or 'q' to quit."
            fi
        done
        
        # Get the selected package name
        local selected_name
        selected_name=$(echo "$matches" | sed -n "${selection}p")
        
        log_info "Selected: $selected_name"
        uninstall_package "$selected_name"
        return $?
    fi
}

uninstall_package() {
    local name="$1"
    
    # Get package information
    local package_info
    package_info=$(get_package_info "$name")
    local package_name
    package_name=$(echo "$package_info" | jq -r '.name // "'"$name"'"')
    local package_type
    package_type=$(echo "$package_info" | jq -r '.type // "npm"')
    
    log_info "Uninstalling $package_name (type: $package_type)"
    
    # Uninstall based on package type
    case "$package_type" in
        "npm")
            uninstall_npm_package "$package_name" "$name"
            ;;
        "pip")
            uninstall_pip_package "$package_name" "$name"
            ;;
        *)
            log_warning "Unknown package type '$package_type', attempting npm uninstall..."
            uninstall_npm_package "$package_name" "$name"
            ;;
    esac
    
    # Remove from tracking
    remove_installed_package "$name"
    remove_mcp_server_config "$name"
    
    log_success "Successfully uninstalled $name"
}

uninstall_npm_package() {
    local package_name="$1"
    local server_name="$2"
    
    # Check if npm is available
    if ! command -v npm >/dev/null 2>&1; then
        log_warning "npm is not available, skipping package uninstall"
        return 0
    fi
    
    log_info "Uninstalling npm package: $package_name"
    
    if npm uninstall -g "$package_name" >/dev/null 2>&1; then
        log_success "Successfully uninstalled npm package: $package_name"
    else
        log_warning "Failed to uninstall npm package: $package_name (may not be installed globally)"
    fi
}

uninstall_pip_package() {
    local package_name="$1"
    local server_name="$2"
    
    # Check if pip is available
    local pip_cmd=""
    if command -v pip3 >/dev/null 2>&1; then
        pip_cmd="pip3"
    elif command -v pip >/dev/null 2>&1; then
        pip_cmd="pip"
    else
        log_warning "pip is not available, skipping package uninstall"
        return 0
    fi
    
    log_info "Uninstalling pip package: $package_name"
    
    if $pip_cmd uninstall -y "$package_name" >/dev/null 2>&1; then
        log_success "Successfully uninstalled pip package: $package_name"
    else
        log_warning "Failed to uninstall pip package: $package_name (may not be installed)"
    fi
}

# Install package from server information
install_from_server_info() {
    local server_info="$1"
    local server_name="$2"
    
    # Extract package information
    local packages
    packages=$(echo "$server_info" | jq -r '.packages // []')
    
    if [[ "$packages" == "[]" ]] || [[ -z "$packages" ]]; then
        log_warning "No packages found for server: $server_name"
        return 1
    fi
    
    # Get the first available package
    local package_name
    package_name=$(echo "$packages" | jq -r '.[0].name // empty')
    local package_type
    package_type=$(echo "$packages" | jq -r '.[0].type // "npm"')
    
    if [[ -z "$package_name" ]]; then
        log_error "No valid package found for server: $server_name"
        return 1
    fi
    
    log_info "Installing package: $package_name (type: $package_type)"
    
    # Install based on package type
    case "$package_type" in
        "npm")
            install_npm_package "$package_name" "$server_name"
            ;;
        "pip")
            install_pip_package "$package_name" "$server_name"
            ;;
        *)
            log_warning "Unknown package type '$package_type', attempting npm install..."
            install_npm_package "$package_name" "$server_name"
            ;;
    esac
}

# Install package directly (fallback)
install_package_direct() {
    local name="$1"
    
    log_info "Attempting direct installation of: $name"
    
    # Try npm first
    if command -v npm >/dev/null 2>&1; then
        log_info "Trying npm installation..."
        if npm install -g "$name" >/dev/null 2>&1; then
            # Add to tracking
            local package_info
            package_info=$(jq -n --arg name "$name" --arg type "npm" --arg version "unknown" '{name: $name, type: $type, version: $version}')
            add_installed_package "$name" "$package_info"
            add_mcp_server_config "$name" "$package_info"
            log_success "Successfully installed $name via npm"
            return 0
        fi
    fi
    
    # Try pip if npm failed
    if command -v pip >/dev/null 2>&1; then
        log_info "Trying pip installation..."
        if pip install "$name" >/dev/null 2>&1; then
            # Add to tracking
            local package_info
            package_info=$(jq -n --arg name "$name" --arg type "pip" --arg version "unknown" '{name: $name, type: $type, version: $version}')
            add_installed_package "$name" "$package_info"
            add_mcp_server_config "$name" "$package_info"
            log_success "Successfully installed $name via pip"
            return 0
        fi
    fi
    
    log_error "Failed to install $name via npm or pip"
    return 1
}


cmd_update() {
    local package_name="${1:-}"
    
    if [[ -n "$package_name" ]]; then
        # Update specific package
        update_specific_package "$package_name"
    else
        # Update all installed packages
        update_all_packages
    fi
}

update_specific_package() {
    local name="$1"
    
    log_info "Updating MCP server: $name"
    
    # Check if package is installed (exact match)
    if is_package_installed "$name"; then
        update_package "$name"
        return $?
    fi
    
    # If not found, try fuzzy matching with installed packages
    log_info "Package '$name' not found, searching installed packages..."
    local installed_packages
    installed_packages=$(get_installed_packages)
    local package_names
    package_names=$(echo "$installed_packages" | jq -r '.packages | keys[]')
    
    local matches
    matches=$(echo "$package_names" | grep -i "$name" || true)
    
    if [[ -z "$matches" ]]; then
        log_warning "No installed packages found matching '$name'"
        echo
        echo "Installed packages:"
        if [[ -n "$package_names" ]]; then
            echo "$package_names" | while read -r pkg; do
                echo "  • $pkg"
            done
        else
            echo "  (none)"
        fi
        return 0
    fi
    
    # Count matches
    local match_count
    match_count=$(echo "$matches" | wc -l)
    
    if [[ $match_count -eq 1 ]]; then
        # Single match found, use it
        local exact_name
        exact_name=$(echo "$matches" | head -n1)
        log_info "Found single match: $exact_name"
        update_package "$exact_name"
        return $?
    else
        # Multiple matches found, prompt user to select
        echo "Found $match_count installed packages matching '$name':"
        echo
        
        local i=1
        echo "$matches" | while read -r package_name; do
            echo "  $i) $package_name"
            ((i++))
        done
        echo
        
        # Check if we're in a non-interactive environment (like tests)
        if [[ ! -t 0 ]] || [[ -n "${BATS_TEST_FILENAME:-}" ]]; then
            # Non-interactive mode - return first match
            local first_match
            first_match=$(echo "$matches" | head -n1)
            log_info "Non-interactive mode: auto-selecting first match: $first_match"
            echo "$first_match"
            return 0
        fi
        
        # Read user selection
        local selection
        while true; do
            echo -n "Select a package to update (1-$match_count) or 'q' to quit: "
            read -r selection
            
            if [[ "$selection" == "q" || "$selection" == "quit" ]]; then
                echo "Cancelled."
                return 1
            fi
            
            if [[ "$selection" =~ ^[0-9]+$ ]] && [[ $selection -ge 1 ]] && [[ $selection -le $match_count ]]; then
                break
            else
                echo "Please enter a number between 1 and $match_count, or 'q' to quit."
            fi
        done
        
        # Get the selected package name
        local selected_name
        selected_name=$(echo "$matches" | sed -n "${selection}p")
        
        log_info "Selected: $selected_name"
        update_package "$selected_name"
        return $?
    fi
}

update_package() {
    local name="$1"
    
    # Get package information
    local package_info
    package_info=$(get_package_info "$name")
    local package_name
    package_name=$(echo "$package_info" | jq -r '.name // "'"$name"'"')
    local package_type
    package_type=$(echo "$package_info" | jq -r '.type // "npm"')
    local current_version
    current_version=$(echo "$package_info" | jq -r '.version // "unknown"')
    
    log_info "Updating $package_name from $current_version (type: $package_type)"
    
    # Update based on package type
    case "$package_type" in
        "npm")
            update_npm_package "$package_name" "$name"
            ;;
        "pip")
            update_pip_package "$package_name" "$name"
            ;;
        *)
            log_warning "Unknown package type '$package_type', attempting npm update..."
            update_npm_package "$package_name" "$name"
            ;;
    esac
}

update_all_packages() {
    log_info "Updating all installed MCP servers"
    
    local installed_packages
    installed_packages=$(get_installed_packages)
    local package_count
    package_count=$(echo "$installed_packages" | jq -r '.packages | length')
    
    if [[ "$package_count" -eq 0 ]]; then
        log_info "No packages installed to update"
        return 0
    fi
    
    echo "Found $package_count installed package(s):"
    echo
    
    # Get list of package names
    local package_names
    package_names=$(echo "$installed_packages" | jq -r '.packages | keys[]')
    
    local updated_count=0
    local failed_count=0
    
    while IFS= read -r package_name; do
        echo "Updating $package_name..."
        if update_specific_package "$package_name"; then
            ((updated_count++))
        else
            ((failed_count++))
        fi
        echo
    done <<< "$package_names"
    
    echo "Update summary:"
    echo "  ✅ Updated: $updated_count"
    echo "  ❌ Failed: $failed_count"
}

update_npm_package() {
    local package_name="$1"
    local server_name="$2"
    
    # Check if npm is available
    if ! command -v npm >/dev/null 2>&1; then
        log_error "npm is not available"
        return 1
    fi
    
    log_info "Updating npm package: $package_name"
    
    # Get latest version
    local latest_version
    latest_version=$(npm view "$package_name" version 2>/dev/null)
    
    if [[ -z "$latest_version" ]]; then
        log_error "Could not get latest version for $package_name"
        return 1
    fi
    
    # Install latest version
    if npm install -g "$package_name@$latest_version" >/dev/null 2>&1; then
        log_success "Successfully updated $package_name to $latest_version"
        
        # Update package tracking
        local package_info
        package_info=$(jq -n --arg name "$package_name" --arg version "$latest_version" --arg type "npm" '{name: $name, version: $version, type: $type, updated_at: now}')
        add_installed_package "$server_name" "$package_info"
        
        return 0
    else
        log_error "Failed to update npm package: $package_name"
        return 1
    fi
}

update_pip_package() {
    local package_name="$1"
    local server_name="$2"
    
    # Check if pip is available
    local pip_cmd=""
    if command -v pip3 >/dev/null 2>&1; then
        pip_cmd="pip3"
    elif command -v pip >/dev/null 2>&1; then
        pip_cmd="pip"
    else
        log_error "pip is not available"
        return 1
    fi
    
    log_info "Updating pip package: $package_name"
    
    # Get latest version
    local latest_version
    latest_version=$($pip_cmd index versions "$package_name" 2>/dev/null | head -n1 | awk '{print $2}' 2>/dev/null)
    
    if [[ -z "$latest_version" ]]; then
        # Fallback: try to upgrade without specifying version
        log_info "Could not get latest version, attempting upgrade..."
        if $pip_cmd install --upgrade "$package_name" >/dev/null 2>&1; then
            log_success "Successfully updated $package_name"
            
            # Update package tracking (version unknown)
            local package_info
            package_info=$(jq -n --arg name "$package_name" --arg version "latest" --arg type "pip" '{name: $name, version: $version, type: $type, updated_at: now}')
            add_installed_package "$server_name" "$package_info"
            
            return 0
        else
            log_error "Failed to update pip package: $package_name"
            return 1
        fi
    fi
    
    # Install specific latest version
    if $pip_cmd install --upgrade "$package_name==$latest_version" >/dev/null 2>&1; then
        log_success "Successfully updated $package_name to $latest_version"
        
        # Update package tracking
        local package_info
        package_info=$(jq -n --arg name "$package_name" --arg version "$latest_version" --arg type "pip" '{name: $name, version: $version, type: $type, updated_at: now}')
        add_installed_package "$server_name" "$package_info"
        
        return 0
    else
        log_error "Failed to update pip package: $package_name"
        return 1
    fi
}

cmd_config() {
    local action="${1:-show}"
    
    case "$action" in
        show)
            echo "MCP Registry CLI Configuration:"
            echo "=============================="
            echo "Registry URL:     $MCP_REGISTRY_BASE_URL"
            echo "Cache Directory:  $CACHE_DIR"
            echo "Config Directory: $CONFIG_DIR"
            echo
            echo "Environment Variables:"
            if [[ -n "${GITHUB_TOKEN:-}" ]]; then
                echo "  GITHUB_TOKEN:     [SET]"
            else
                echo "  GITHUB_TOKEN:     [NOT SET]"
            fi
            if [[ -n "${GITHUB_AUTH_TOKEN:-}" ]]; then
                echo "  GITHUB_AUTH_TOKEN: [SET]"
            else
                echo "  GITHUB_AUTH_TOKEN: [NOT SET]"
            fi
            echo
            echo "GitHub CLI Status:"
            if command -v gh >/dev/null 2>&1; then
                if gh auth status >/dev/null 2>&1; then
                    local gh_user
                    gh_user=$(gh api user --jq '.login' 2>/dev/null || echo "unknown")
                    echo "  GitHub CLI:       [AUTHENTICATED] (user: $gh_user)"
                else
                    echo "  GitHub CLI:       [NOT AUTHENTICATED]"
                fi
            else
                echo "  GitHub CLI:       [NOT INSTALLED]"
            fi
            echo
            echo "Cache Status:"
            local cache_files
            cache_files=$(find "$CACHE_DIR" -name "*.json" 2>/dev/null | wc -l)
            echo "  Cached files: $cache_files"
            ;;
        clear-cache)
            log_info "Clearing cache directory: $CACHE_DIR"
            if [[ -d "$CACHE_DIR" ]]; then
                rm -rf "${CACHE_DIR:?}"/*
                log_success "Cache cleared successfully"
            else
                log_info "Cache directory does not exist"
            fi
            ;;
        cache-info)
            echo "Cache Information:"
            echo "=================="
            if [[ -d "$CACHE_DIR" ]]; then
                local cache_files
                cache_files=$(find "$CACHE_DIR" -name "*.json" 2>/dev/null)
                if [[ -n "$cache_files" ]]; then
                    echo "Cached endpoints:"
                    echo "$cache_files" | while read -r file; do
                        local basename_file
                        basename_file=$(basename "$file" .json)
                        local file_age
                        file_age=$(($(date +%s) - $(stat -f %m "$file" 2>/dev/null || stat -c %Y "$file" 2>/dev/null)))
                        local age_minutes=$((file_age / 60))
                        echo "  • $basename_file (age: ${age_minutes}m)"
                    done
                else
                    echo "No cached files found"
                fi
            else
                echo "Cache directory does not exist"
            fi
            ;;
        *)
            echo "Usage: $SCRIPT_NAME config [show|clear-cache|cache-info]"
            echo
            echo "Commands:"
            echo "  show         Show current configuration (default)"
            echo "  clear-cache  Clear all cached data"
            echo "  cache-info   Show detailed cache information"
            ;;
    esac
}

cmd_installed() {
    log_info "Listing installed MCP servers"
    
    local installed_packages
    installed_packages=$(get_installed_packages)
    local package_count
    package_count=$(echo "$installed_packages" | jq -r '.packages | length')
    
    if [[ "$package_count" -eq 0 ]]; then
        echo "No MCP servers installed."
        echo
        echo "To install a server, use:"
        echo "  $SCRIPT_NAME install <server-name>"
        echo
        echo "To see available servers, use:"
        echo "  $SCRIPT_NAME list"
        return 0
    fi
    
    echo "Installed MCP servers ($package_count total):"
    echo
    
    # Get package names and display them
    local package_names
    package_names=$(echo "$installed_packages" | jq -r '.packages | keys[]')
    
    while IFS= read -r package_name; do
        local package_info
        package_info=$(get_package_info "$package_name")
        local name
        name=$(echo "$package_info" | jq -r '.name // "'"$package_name"'"')
        local version
        version=$(echo "$package_info" | jq -r '.version // "unknown"')
        local type
        type=$(echo "$package_info" | jq -r '.type // "unknown"')
        
        echo "  • $package_name"
        echo "    Package: $name@$version ($type)"
        echo
    done <<< "$package_names"
    
    echo "To update all packages: $SCRIPT_NAME update"
    echo "To update a specific package: $SCRIPT_NAME update <name>"
}

cmd_commands() {
    echo "Available commands:"
    echo "  search <query>     Search for MCP servers"
    echo "  list               List available MCP servers"
    echo "  installed          List installed MCP servers"
    echo "  install <name>     Install an MCP server (supports fuzzy matching)"
    echo "  info <name>        Get information about an MCP server (supports fuzzy matching)"
    echo "  uninstall <name>   Uninstall an MCP server (supports fuzzy matching)"
    echo "  update [name]      Update installed MCP servers (all or specific, supports fuzzy matching)"
    echo "  config             Manage configuration"
    echo "  auth               Authenticate with GitHub CLI (gh auth login)"
    echo "  commands           List available commands"
    echo "  --help, -h         Show help message"
    echo "  --version, -v      Show version information"
}

# Main function
main() {
    # Check dependencies
    check_dependencies
    
    # Initialize directories
    init_directories
    
    # Check authentication
    check_auth
    
    # Parse command line arguments
    if [[ $# -eq 0 ]]; then
        show_help
        exit 0
    fi
    
    case "${1:-}" in
        search)
            cmd_search "${2:-}"
            ;;
        list)
            cmd_list "$@"
            ;;
        installed)
            cmd_installed
            ;;
        install)
            cmd_install "${2:-}"
            ;;
        info)
            cmd_info "${2:-}"
            ;;
        uninstall)
            cmd_uninstall "${2:-}"
            ;;
        update)
            cmd_update "${2:-}"
            ;;
        config)
            cmd_config "${2:-}"
            ;;
        auth)
            browser_auth
            ;;
        commands)
            cmd_commands
            ;;
        --help|-h)
            show_help
            ;;
        --version|-v)
            show_version
            ;;
        *)
            log_error "Unknown command: $1"
            log_info "Run '$SCRIPT_NAME --help' for usage information."
            exit 1
            ;;
    esac
}

# Run main function with all arguments
main "$@"
