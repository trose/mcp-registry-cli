#!/bin/bash

# MCP Registry CLI - A pleasant-to-use command-line tool for the MCP Registry
# Version: 0.0.1
# Author: MCP Registry CLI Team

set -euo pipefail

# Script directory and configuration
readonly SCRIPT_DIR
readonly SCRIPT_NAME
SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
SCRIPT_NAME="$(basename "$0")"
readonly VERSION="0.1.0"

# Configuration
readonly MCP_REGISTRY_BASE_URL="${MCP_REGISTRY_BASE_URL:-https://registry.modelcontextprotocol.io}"
readonly CACHE_DIR="${MCP_CACHE_DIR:-$HOME/.cache/mcpreg}"
readonly CONFIG_DIR="${MCP_CONFIG_DIR:-$HOME/.config/mcpreg}"

# Colors for output
readonly RED='\033[0;31m'
readonly GREEN='\033[0;32m'
readonly YELLOW='\033[1;33m'
readonly BLUE='\033[0;34m'
readonly NC='\033[0m' # No Color

# Logging functions
log_info() {
    echo -e "${BLUE}[INFO]${NC} $*" >&2
}

log_success() {
    echo -e "${GREEN}[SUCCESS]${NC} $*" >&2
}

log_warning() {
    echo -e "${YELLOW}[WARNING]${NC} $*" >&2
}

log_error() {
    echo -e "${RED}[ERROR]${NC} $*" >&2
}

# Error handling
error_exit() {
    log_error "$1"
    exit "${2:-1}"
}

# Help function
show_help() {
    cat << EOF
MCP Registry CLI - A pleasant-to-use command-line tool for the MCP Registry

USAGE:
    $SCRIPT_NAME <command> [options]

COMMANDS:
    search <query>     Search for MCP servers
    list               List available MCP servers
    install <name>     Install an MCP server
    info <name>        Get information about an MCP server
    uninstall <name>   Uninstall an MCP server
    update             Update installed MCP servers
    config [action]    Manage configuration (show|clear-cache|cache-info)
    auth               Authenticate with GitHub CLI (gh auth login)
    commands           List available commands
    --help, -h         Show this help message
    --version, -v      Show version information

EXAMPLES:
    $SCRIPT_NAME search filesystem
    $SCRIPT_NAME list
    $SCRIPT_NAME install filesystem
    $SCRIPT_NAME info filesystem
    $SCRIPT_NAME config
    $SCRIPT_NAME config clear-cache

ENVIRONMENT VARIABLES:
    GITHUB_TOKEN           GitHub authentication token (seamless auth)
    GITHUB_AUTH_TOKEN      Alternative GitHub authentication token
    MCP_REGISTRY_BASE_URL  MCP Registry base URL (default: https://registry.modelcontextprotocol.io)
    MCP_CACHE_DIR          Cache directory (default: ~/.cache/mcpreg)
    MCP_CONFIG_DIR         Config directory (default: ~/.config/mcpreg)

For more information, visit: https://github.com/your-org/mcp-registry-cli
EOF
}

# Version function
show_version() {
    echo "$SCRIPT_NAME version $VERSION"
}

# Check dependencies
check_dependencies() {
    local missing_deps=()
    
    # Check for required commands
    command -v curl >/dev/null 2>&1 || missing_deps+=("curl")
    command -v jq >/dev/null 2>&1 || missing_deps+=("jq")
    
    if [[ ${#missing_deps[@]} -gt 0 ]]; then
        log_error "Missing required dependencies: ${missing_deps[*]}"
        log_info "Please install the missing dependencies and try again."
        log_info "On macOS: brew install curl jq"
        log_info "On Ubuntu/Debian: sudo apt-get install curl jq"
        log_info "On CentOS/RHEL: sudo yum install curl jq"
        exit 1
    fi
}

# Initialize directories
init_directories() {
    mkdir -p "$CACHE_DIR" "$CONFIG_DIR"
}

# Caching functions
get_cache_file() {
    local endpoint="$1"
    # Create a safe filename from the endpoint
    local safe_name
    safe_name=$(echo "$endpoint" | sed 's/[^a-zA-Z0-9._-]/_/g')
    echo "$CACHE_DIR/${safe_name}.json"
}

is_cache_valid() {
    local cache_file="$1"
    local max_age="${2:-300}" # Default 5 minutes
    
    if [[ ! -f "$cache_file" ]]; then
        return 1
    fi
    
    local file_age
    file_age=$(($(date +%s) - $(stat -f %m "$cache_file" 2>/dev/null || stat -c %Y "$cache_file" 2>/dev/null)))
    
    if [[ $file_age -lt $max_age ]]; then
        return 0
    else
        return 1
    fi
}

get_from_cache() {
    local cache_file="$1"
    
    if [[ -f "$cache_file" ]]; then
        cat "$cache_file"
        return 0
    else
        return 1
    fi
}

save_to_cache() {
    local cache_file="$1"
    local data="$2"
    
    echo "$data" > "$cache_file"
}

# Enhanced API call with caching
api_call_with_cache() {
    local endpoint="$1"
    local method="${2:-GET}"
    local data="${3:-}"
    local cache_ttl="${4:-300}" # Default 5 minutes cache
    
    local cache_file
    cache_file=$(get_cache_file "$endpoint")
    
    # For GET requests, try cache first
    if [[ "$method" == "GET" ]] && is_cache_valid "$cache_file" "$cache_ttl"; then
        log_info "Using cached data for $endpoint"
        get_from_cache "$cache_file"
        return 0
    fi
    
    # Make API call
    local response
    response=$(api_call "$endpoint" "$method" "$data")
    local api_result=$?
    
    # Cache successful GET responses
    if [[ $api_result -eq 0 ]] && [[ "$method" == "GET" ]]; then
        save_to_cache "$cache_file" "$response"
    fi
    
    echo "$response"
    return $api_result
}

# Authentication functions
validate_github_token() {
    local token="$1"
    
    if [[ -z "$token" ]]; then
        return 1
    fi
    
    # Test token by making a simple API call to GitHub
    local response
    response=$(curl -s -w "\n%{http_code}" \
        -H "Authorization: Bearer $token" \
        -H "Accept: application/vnd.github.v3+json" \
        "https://api.github.com/user" 2>/dev/null)
    
    if [[ $? -ne 0 ]]; then
        return 1
    fi
    
    local http_code
    http_code=$(echo "$response" | tail -n1)
    local body
    body=$(echo "$response" | sed '$d')
    
    if [[ "$http_code" -eq 200 ]]; then
        local username
        username=$(echo "$body" | jq -r '.login // "unknown"' 2>/dev/null)
        log_info "GitHub token validated for user: $username"
        return 0
    else
        log_warning "GitHub token validation failed (status: $http_code)"
        return 1
    fi
}

check_auth() {
    local token=""
    
    # Check for GitHub tokens in environment variables first
    if [[ -n "${GITHUB_TOKEN:-}" ]]; then
        token="$GITHUB_TOKEN"
    elif [[ -n "${GITHUB_AUTH_TOKEN:-}" ]]; then
        token="$GITHUB_AUTH_TOKEN"
    fi
    
    # If no env token, try to get token from GitHub CLI
    if [[ -z "$token" ]] && command -v gh >/dev/null 2>&1; then
        if gh auth status >/dev/null 2>&1; then
            token=$(gh auth token 2>/dev/null)
            if [[ -n "$token" ]]; then
                log_info "Using GitHub CLI authentication"
            fi
        fi
    fi
    
    if [[ -n "$token" ]]; then
        if validate_github_token "$token"; then
            log_info "Using validated GitHub token for authentication"
            return 0
        else
            log_warning "GitHub token is invalid or expired"
            return 1
        fi
    else
        log_info "No GitHub authentication found"
        log_info "Run 'mcpreg auth' to authenticate with GitHub CLI"
        return 0  # Don't exit on missing token, just log info
    fi
}

# GitHub CLI authentication
browser_auth() {
    log_info "Setting up GitHub authentication using GitHub CLI..."
    
    # Check if gh CLI is installed
    if ! command -v gh >/dev/null 2>&1; then
        log_error "GitHub CLI (gh) is not installed"
        log_info "Please install it first:"
        log_info "  macOS: brew install gh"
        log_info "  Linux: https://cli.github.com/"
        log_info "  Windows: winget install GitHub.cli"
        return 1
    fi
    
    # Check if already authenticated
    if gh auth status >/dev/null 2>&1; then
        log_info "GitHub CLI is already authenticated"
        log_success "Using existing GitHub CLI authentication"
        return 0
    fi
    
    # Authenticate with GitHub CLI
    log_info "Starting GitHub CLI authentication..."
    log_info "This will open your browser for GitHub OAuth"
    
    if gh auth login --web >/dev/null 2>&1; then
        log_success "GitHub authentication completed successfully"
        return 0
    else
        log_error "GitHub authentication failed"
        log_info "You can also set GITHUB_TOKEN manually:"
        log_info "  export GITHUB_TOKEN=your_token_here"
        return 1
    fi
}

# API functions
api_call() {
    local endpoint="$1"
    local method="${2:-GET}"
    local data="${3:-}"
    
    local url="${MCP_REGISTRY_BASE_URL}${endpoint}"
    local curl_args=(-s -w "\n%{http_code}")
    
    if [[ "$method" == "POST" ]] && [[ -n "$data" ]]; then
        curl_args+=(-X POST -H "Content-Type: application/json" -d "$data")
    fi
    
    # Add authentication if available
    if [[ -n "${GITHUB_TOKEN:-}" ]]; then
        curl_args+=(-H "Authorization: Bearer $GITHUB_TOKEN")
    elif [[ -n "${GITHUB_AUTH_TOKEN:-}" ]]; then
        curl_args+=(-H "Authorization: Bearer $GITHUB_AUTH_TOKEN")
    fi
    
    local response
    if ! response=$(curl "${curl_args[@]}" "$url" 2>/dev/null); then
        error_exit "Failed to connect to MCP Registry"
    fi
    
    local http_code
    http_code=$(echo "$response" | tail -n1)
    local body
    body=$(echo "$response" | sed '$d')
    
    if [[ "$http_code" -ge 400 ]]; then
        log_warning "API request failed with status $http_code"
        echo "$body" | jq -r '.message // .error // "Unknown error"' 2>/dev/null || echo "$body"
        return 1
    fi
    
    echo "$body"
}

# Command functions
cmd_search() {
    local query="${1:-}"
    if [[ -z "$query" ]]; then
        error_exit "Search query is required. Usage: $SCRIPT_NAME search <query>"
    fi
    
    log_info "Searching for: $query"
    
    local response
    response=$(api_call_with_cache "/v0/servers?search=$query") || {
        log_warning "API is currently unavailable. Showing example results."
        echo "MCP Registry API is currently experiencing issues."
        echo "Example servers matching '$query':"
        echo "  • io.modelcontextprotocol/filesystem - Filesystem operations server"
        echo "  • io.modelcontextprotocol/git - Git repository operations"
        return 0
    }
    
    local count
    count=$(echo "$response" | jq -r '.metadata.count // 0')
    
    if [[ "$count" -eq 0 ]]; then
        echo "No servers found matching '$query'"
        return 0
    fi
    
    echo "Found $count server(s) matching '$query':"
    echo
    
    echo "$response" | jq -r '.servers[] | "\(.name) - \(.description // "No description")"' | while read -r line; do
        echo "  • $line"
    done
}

cmd_list() {
    local limit="${1:-20}"
    
    log_info "Listing available MCP servers (limit: $limit)"
    
    local response
    response=$(api_call_with_cache "/v0/servers?limit=$limit") || {
        log_warning "API is currently unavailable. Showing cached data or placeholder."
        # For now, show a placeholder message
        echo "MCP Registry API is currently experiencing issues."
        echo "Please try again later or check https://registry.modelcontextprotocol.io for status."
        echo
        echo "Example servers that would be available:"
        echo "  • io.modelcontextprotocol/filesystem - Filesystem operations server"
        echo "  • io.modelcontextprotocol/git - Git repository operations"
        echo "  • io.modelcontextprotocol/sqlite - SQLite database operations"
        return 0
    }
    
    local count
    count=$(echo "$response" | jq -r '.metadata.count // 0')
    
    echo "Available MCP servers ($count total):"
    echo
    
    echo "$response" | jq -r '.servers[] | "\(.name) - \(.description // "No description")"' | while read -r line; do
        echo "  • $line"
    done
}

cmd_install() {
    local name="${1:-}"
    if [[ -z "$name" ]]; then
        error_exit "Server name is required. Usage: $SCRIPT_NAME install <name>"
    fi
    
    log_info "Installing MCP server: $name"
    # TODO: Implement install functionality
    echo "Install functionality coming soon..."
}

cmd_info() {
    local name="${1:-}"
    if [[ -z "$name" ]]; then
        error_exit "Server name is required. Usage: $SCRIPT_NAME info <name>"
    fi
    
    log_info "Getting information for: $name"
    
    local response
    if ! response=$(api_call_with_cache "/v0/servers/$name"); then
        error_exit "Failed to get server information"
    fi
    
    # Parse and display server information
    local server_name
    server_name=$(echo "$response" | jq -r '.name // "Unknown"')
    local description
    description=$(echo "$response" | jq -r '.description // "No description"')
    local version
    version=$(echo "$response" | jq -r '.version // "Unknown"')
    local status
    status=$(echo "$response" | jq -r '.status // "Unknown"')
    
    echo "Server Information:"
    echo "=================="
    echo "Name:        $server_name"
    echo "Description: $description"
    echo "Version:     $version"
    echo "Status:      $status"
    echo
    
    # Show packages if available
    local packages
    packages=$(echo "$response" | jq -r '.packages[]? | "\(.registry_type): \(.identifier)@\(.version)"' 2>/dev/null)
    
    if [[ -n "$packages" ]]; then
        echo "Packages:"
        echo "$packages" | while read -r package; do
            echo "  • $package"
        done
        echo
    fi
    
    # Show remotes if available
    local remotes
    remotes=$(echo "$response" | jq -r '.remotes[]? | "\(.type): \(.url)"' 2>/dev/null)
    
    if [[ -n "$remotes" ]]; then
        echo "Remotes:"
        echo "$remotes" | while read -r remote; do
            echo "  • $remote"
        done
        echo
    fi
}

cmd_uninstall() {
    local name="${1:-}"
    if [[ -z "$name" ]]; then
        error_exit "Server name is required. Usage: $SCRIPT_NAME uninstall <name>"
    fi
    
    log_info "Uninstalling MCP server: $name"
    # TODO: Implement uninstall functionality
    echo "Uninstall functionality coming soon..."
}

cmd_update() {
    log_info "Updating MCP servers"
    # TODO: Implement update functionality
    echo "Update functionality coming soon..."
}

cmd_config() {
    local action="${1:-show}"
    
    case "$action" in
        show)
            echo "MCP Registry CLI Configuration:"
            echo "=============================="
            echo "Registry URL:     $MCP_REGISTRY_BASE_URL"
            echo "Cache Directory:  $CACHE_DIR"
            echo "Config Directory: $CONFIG_DIR"
            echo
            echo "Environment Variables:"
            if [[ -n "${GITHUB_TOKEN:-}" ]]; then
                echo "  GITHUB_TOKEN:     [SET]"
            else
                echo "  GITHUB_TOKEN:     [NOT SET]"
            fi
            if [[ -n "${GITHUB_AUTH_TOKEN:-}" ]]; then
                echo "  GITHUB_AUTH_TOKEN: [SET]"
            else
                echo "  GITHUB_AUTH_TOKEN: [NOT SET]"
            fi
            echo
            echo "GitHub CLI Status:"
            if command -v gh >/dev/null 2>&1; then
                if gh auth status >/dev/null 2>&1; then
                    local gh_user
                    gh_user=$(gh api user --jq '.login' 2>/dev/null || echo "unknown")
                    echo "  GitHub CLI:       [AUTHENTICATED] (user: $gh_user)"
                else
                    echo "  GitHub CLI:       [NOT AUTHENTICATED]"
                fi
            else
                echo "  GitHub CLI:       [NOT INSTALLED]"
            fi
            echo
            echo "Cache Status:"
            local cache_files
            cache_files=$(find "$CACHE_DIR" -name "*.json" 2>/dev/null | wc -l)
            echo "  Cached files: $cache_files"
            ;;
        clear-cache)
            log_info "Clearing cache directory: $CACHE_DIR"
            if [[ -d "$CACHE_DIR" ]]; then
                rm -rf "${CACHE_DIR:?}"/*
                log_success "Cache cleared successfully"
            else
                log_info "Cache directory does not exist"
            fi
            ;;
        cache-info)
            echo "Cache Information:"
            echo "=================="
            if [[ -d "$CACHE_DIR" ]]; then
                local cache_files
                cache_files=$(find "$CACHE_DIR" -name "*.json" 2>/dev/null)
                if [[ -n "$cache_files" ]]; then
                    echo "Cached endpoints:"
                    echo "$cache_files" | while read -r file; do
                        local basename_file
                        basename_file=$(basename "$file" .json)
                        local file_age
                        file_age=$(($(date +%s) - $(stat -f %m "$file" 2>/dev/null || stat -c %Y "$file" 2>/dev/null)))
                        local age_minutes=$((file_age / 60))
                        echo "  • $basename_file (age: ${age_minutes}m)"
                    done
                else
                    echo "No cached files found"
                fi
            else
                echo "Cache directory does not exist"
            fi
            ;;
        *)
            echo "Usage: $SCRIPT_NAME config [show|clear-cache|cache-info]"
            echo
            echo "Commands:"
            echo "  show         Show current configuration (default)"
            echo "  clear-cache  Clear all cached data"
            echo "  cache-info   Show detailed cache information"
            ;;
    esac
}

cmd_commands() {
    echo "Available commands:"
    echo "  search <query>     Search for MCP servers"
    echo "  list               List available MCP servers"
    echo "  install <name>     Install an MCP server"
    echo "  info <name>        Get information about an MCP server"
    echo "  uninstall <name>   Uninstall an MCP server"
    echo "  update             Update installed MCP servers"
    echo "  config             Manage configuration"
    echo "  auth               Authenticate with GitHub CLI (gh auth login)"
    echo "  commands           List available commands"
    echo "  --help, -h         Show help message"
    echo "  --version, -v      Show version information"
}

# Main function
main() {
    # Check dependencies
    check_dependencies
    
    # Initialize directories
    init_directories
    
    # Check authentication
    check_auth
    
    # Parse command line arguments
    if [[ $# -eq 0 ]]; then
        show_help
        exit 0
    fi
    
    case "${1:-}" in
        search)
            cmd_search "${2:-}"
            ;;
        list)
            cmd_list "$@"
            ;;
        install)
            cmd_install "${2:-}"
            ;;
        info)
            cmd_info "${2:-}"
            ;;
        uninstall)
            cmd_uninstall "${2:-}"
            ;;
        update)
            cmd_update
            ;;
        config)
            cmd_config "${2:-}"
            ;;
        auth)
            browser_auth
            ;;
        commands)
            cmd_commands
            ;;
        --help|-h)
            show_help
            ;;
        --version|-v)
            show_version
            ;;
        *)
            log_error "Unknown command: $1"
            log_info "Run '$SCRIPT_NAME --help' for usage information."
            exit 1
            ;;
    esac
}

# Run main function with all arguments
main "$@"
